BST와 MST 계열 인덱스의 비교
* 메모리 적재용 인덱스 (BST 계열) => (메모리 주소를 저장해야 한다) => m이 커질시 노드의 크기가 너무 커진다
    * 키의 개수가 크지 않을 때
    * 트리의 깊이가 깊어도 유지가 간단한 구조
    * BST, AVL 트리
* 디스크 적재용 인덱스 (MST 계열)
    * 키의 개수가 너무 클 때
    * 유지가 힘들더라도, 트리의 깊이 최소화
    * MST, B트리(Balanced MST)
    * 특히 B-트리의 경우
        * 모든 non-leaf는 메모리,
        * 모든 leaf는 디스크에 저장하여 성능을 향상.(leaf에 노드가 너무 많아서 디스크에 저장)
            * N=1,000,000이고 m=100이면, 3 ≤ h ≤ 5.
            * N=1,000,000,000이고 m=200이면, 4 ≤ h ≤ 5.

* B* 트리 (B 스타 트리)
    * 각 노드 마다 키 값이 최소 2/3 이상 찬 상태
    * B*-트리 : 공백이거나 높이가 1 이상인 m-원 탐색 트리
    * 루트는 단말 노드가 아닌 이상 최소 2개, 최대 ((2m-2)/3 x 2) +1 개의 서브트리를 갖는다.
    * 루트와 단말 노드를 제외한 모든 노드는 적어도 (2m-2)/3+1개의 서브트리, 즉 최소 (2m-2)/3 개의 키 값을 갖는다.
    * 모든 리프는 같은 레벨에 있다.
    * 삽입    
        * 노드가 가득 찬 경우 삽입
            – B-트리: 즉시 분할
            – B*-트리: 분할 대신 인접한 형제 노드로 키를 재분배(key redistribution)시킴.
        * 두 개의 이웃 노드가 모두 가득 찼을 때의 삽입
            – 두 개의 노드를 세 개로 분할시킴.
            – 분할된 세 개 노드는 각각 2/3만 참
        * 84p 루트는 분할되야 하는데 하위노드의 2/3를 채워야 하므로 8개인 상태에서 삽입됬을때 분할한다

* 트라이 (Trie)=> 빌드할때 삽입삭제를 사용한 후부터는 삽입삭제는 별로 쓰지않음
    * 90p
    셀 개수 10개
    4자리숫자:
    루트 :  2   3   5   7   천
    깊이2:(3 5...)          백
    깊이3:(0 5)             십
    깊이4:(2,3..)           일