# 순차 화일 : 마스터 - 트랜잭션 화일
실제로 사용 가능한 구조
## 기본 구조
* 트랜잭션 화일`(삽입,삭제,수정 표시칸이 따로 있음)`
    * 레코드 수집 및 편집을 위해, 입력 레코드를 임시로 보관하는곳 
        * 즉 레코드의 삽입만 이루어진다
        * 여기에 저장되는 레코드에 대한 삭제 및 수정은 없다
    * 입력 순차 화일 형태
        * 레코드가 입력된 순서대로 저장된다. 즉 `정렬되어 있지 않다`
* 마스터 화일
    * 레코드를 영구히 보관하는 곳
    * 키 순차화일 형태
        * 필드 혹은 정렬 키의 값에 따라, 레코드들이 `정렬되어 있다`
## 기본 동작
    1. 우선 트랜잭션 화일을 정렬한다
    2. 두 개의 sort 된 화일을 merge(합병)한다 
    
    레코드에 대한 “실제” 갱신(삽입/삭제/수정)은 
    트랜잭션 화일과 마스터 화일의 합병(merge)을 통해 이루어짐.

### 검색 알고리즘
* 이상적
    1. 트랜잭션 화일에서 찾아본다 O(n)
    2. 마스터 화일에서 찾아본다 O(logn)
* 실제
    * 트랜잭션 화일은 너무 느리기 때문에 마스터 화일에서만 검색한다
        * 합병하기 전까진 최신 데이터를 읽을 수 없다
    * 트랜잭션 화일의 내용은 마스터 화일에 합병된 후에야 검색결과에 포함된다.

### 갱신 알고리즘
마스터 트랜잭션 화일은 검색 수정 삭제가 동시에 된다??   
1. 트랜잭션과 마스터를 비교후 작은 값을 찾는다
    1. 마스터가 낮을시 새로운 레코드에 입력한 후 포인터를 내린다
    2. 트랜잭션이 낮을시 (삽입,삭제,수정) 새로운 레코드에 입력한다
        1. 만약 트랜잭션이 삽입이면 포인터를 내려서 계속 진행한다.
        2. 만약 트랜잭션이 삭제이면 마스터와 동일한 값이 나올 경우 새 레코드에서 제거해준다.   
            이후 둘 다 포인터를 내려준다
        3. 만약 트랜잭션이 수정이면 마스터와 동일한 값이 나올 경우 새 레코드에서 value값을 수정해준다   
            이후 둘 다 포인터를 내려준다
2. 트랜잭션의 마지막(EOF)에 왔을 시 
    1. 마스터의 마지막에 왔으면 종료
    2. 마스터의 마지막에 안 왔으면 나머지 마스터 화일을 새 레코드에 전부 복사
3. 트랜잭션이 마지막에 안 왔는데 마스터가 마지막(EOF)에 왔을 시
    1. 삽입일 경우 전부 새 레코드에 삽입 후 포인터를 내린다
    2. 수정,삭제일 경우 에러이다
4. 둘다 끝이 아닌 경우
    1. 둘의 키가 동일한 경우
        1. 삽입일 경우 에러
        2. 수정, 삭제일 경우 맞는 처리를 해준 후 양쪽의 포인터를 내린다.
    2. 트랜잭션의 키가 낮을 경우
        1. 삽입일 경우 새 레코드에 삽입 후 포인터를 내린다
        2. 수정, 삭제일 경우 에러
    3. 마스터의 키가 낮을 경우
        1. 새 레코드에 삽입 후 포인터를 내린다

BUT 실제 상황에서는 동일한 키에 대한 다른 처리가 다수 일어날 수 있다(여러 개의 레코드가 나올 수 있다)
=> 키값으로 1차 sort를 하고 시간으로 2차 sort를 해준다
=> 트랜잭션에 timestamp 영역을 만들어준다.
26p 그래프를 어떻게 고쳐야 하는가? 생각해보자
