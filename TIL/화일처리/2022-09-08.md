# 블로킹
## 블록

    디스크와 메인 메모리 사이의 전송되는 데이터의 논리적 단위

* 데이터 전송의 단위: 물리적 레코드
    * 만약 레코드 한 줄이 100Byte이고 Block의 단위가 1kByte라면 한 개의 레코드를 요청해도 10개의 레코드를 전송한다.
        * BF(블로킹 팩터)=> (1024/100)=10

22p BF=3 
1개의 레코드만 가져올 수 없다. => 읽어온 3개의 레코드를 입력버퍼에 저장한다. => 작업구역에서 레코드1를 가져온 후 처리를 한다 => 출력버퍼에 저장한다. => 입력버퍼에서 레코드2를 확인한다 => .. => 입력버퍼에서 레코드4를 확인한다. => 입력버퍼에 레코드 4가 없으므로 블록 단위로 레코드4,5,6를 입력버퍼에 저장한다. => .. => 출력버퍼가 차있으므로 레코드 1,2,3를 HDD에 저장한 후, 출력버퍼에 레코드4를 저장한다.

HDD -> 메인메모리 [ 입력버퍼 -> 작업구역 -> 출력버퍼 -> 입력버퍼 -> ...] -> HDD

블록의 크기 결정
    너무 크면 : 불필요한 데이터 전송
        데이터를 랜덤하게 선택하는(random access) 경우 (ex> 텍스트 데이터)
            블록의 크기가 작을수록 이득
    너무 작으면 : 디스크 접근 및 블록 전송 빈도 증가
        데이터가 연속적으로 선택하는(sequence access) 경우 (ex> 영상)
            블록의 크기가 클수록 이득

고정 길이 레코드와 가변 길이 레코드
    블록 내에서 레코드의 식별
        고정 길이 레코드 (처리시간 감소, 저장공간 증가)
            길이만 알면 레코드 구분 가능
        가변 길이 레코드 (처리시간 증가, 저장공간 감소)
            (24p )
            분리 표시(레코드 끝 마크 : end of record marker)
            각 레코드 앞에 길이 지시자 (length indicator)
            위치 테이블 (각 레코드가 시작하는 위치) (position table)
                random access일 때는 위치 테이블이 가장 유리하다. (but 다른 방식보다 공간을 더 차지한다.)
        
CD-ROM (하드디스크랑은 다르다)


RAID    (디스크 어레이, 병렬)
    많은 수의 저가 소형 디스크 어레이를 구성
        대용량 데이터 저장
    많은 수의 디스크를 병렬로 작동
        데이터 판독/기록 속도의 개선 (속도가 디스크의 개수에 비례한다)
    다중 디스크에 정보를 중복 저장
        신뢰성 증가
    32p(3,5번 중요 패러티 3번 패러티는 비트단위, 5번 패러티는 블럭단위, 차이점 패러티 데이터 크기)

    디스크 여러개를 하나의 Array로 묶는 거
    => sw striping 여러 장점이 있지만 
        but 디스크 한 개가 깨질 시 전체 디스크 사용 불가
    대안 : 미러링
        디스크 2배 사용 => 비용의 증가
    또다른 대안 : 하나의 여유 디스크(parity)
        parity: 적은 데이터로 데이터 무결성을 검사할 수 있다. 미러링보다 비용이 감소한다.
    총 단점
        가격, 소음 (여러 개의 디스크가 동시에 돌아감)