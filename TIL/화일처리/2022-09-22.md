# 인덱스 구조
sequence file:
    파일 갱신(삽입,수정,삭제)가 어렵다
즉 디스크에는 자유도가 높게(순서,제약 상관없이) 저장되어야한다
하지만 검색할 때 오래 걸리기 때문에 디스크에 저장돼 있는 레코드들의 키값과 주소(인덱스)를 정렬된 형태로 저장한 작은 용량을 메인메모리에(?) 만든다

* 인덱스
    * 목적
        * 화일 내의 레코드들에 대한 효율적 접근
    * 정의
        * <레코드 키 값, 레코드 주소(포인터)> 쌍, 즉 인덱스 엔드리의 집합
    * 레코드 주소
        * 디스크 팩 번호, 서피스 번호, 트랙 번호(실린더 번호), 섹터 번호

    * 트리인덱스(만약 테이블로 저장하면 인덱스 역시 갱신에 어려움이 생기기 때문)
## 트리 인덱스
* BST 계열
    * 이원 탐색 트리 (BST)
    * AVL 트리
* MST 계열 
    * m-원 탐색 트리 (MST)
    * `B-트리` (Balanced MST)

### 순차 화일과 인덱스 화일
#### 순차화일
* 하드 디스크에 있는 마스터 파일은 키 값으로 정렬되어 있다
* 순차 접근에 특화됨 (인덱스 화일은 다음 파일로 갈 때마다 디스크 엑세스가 필요하다)
* 임의 접근: 마스터 파일에 대한 이진 탐색으로 가능
    * 최대 log2N (평균도 비슷하다) 만큼의 디스크 엑세스가 필요함(인덱스 화일은 1번의 디스크 엑세스가 필요하다)
=> 순차접근(sequence access)은 순차화일이 임의 접근(random access)은 인덱스 화일이 유리하다
#### 인덱스 화일
* 별도의 트리 인덱스를 메인 메모리에 유지함.
    * 하드 디스크에 있는 레코드들은 정렬 안 된 상태임.
    * 그러나 트리 인덱스는 정렬된 상태임.
* 임의 접근에 특화됨.
    * 최소 log2N 만큼의 메모리 엑세스가 필요함.
    * 디스크 엑세스는 단 한번만 필요.
* 순차 접근: 트리 인덱스에 대한 in-order 순회로 이론적으로는 가능하나, 레코드 개수가 늘어나면 매우 느림.
    *  N 번의 디스크 엑세스가 필요함.
    * 또한 트리 인덱스에 대한 recursive call로 인하여, 레코드의 개수가 많아지면 stack overflow 에러가 발생할 수 있음.
